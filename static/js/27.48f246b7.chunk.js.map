{"version":3,"sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","skins/JurassicUnix/JurassicUnix.constants.tsx","skins/JurassicUnix/types/perspective-type.tsx","skins/JurassicUnix/JurassicUnix.helpers.tsx","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","SIZE_UNIT","SCENE_WIDTH","BASE_HUE","HUE_INCREMENT","BOX_MARGIN","PerspectiveType","getPerspectiveFor","x","y","z","width","perspectiveType","offset","objectTopCentre","SIDE_VIEW","windowAspectRatio","window","innerWidth","innerHeight","Math","max","viewPoint","addCoordinates","get3DTranslation","get3DRotation","direction","degrees","toUpperCase","position1","position2","pos1","pos2","isPrimitive","value","capitalize","str","spaced","split","reduce","newString","nextChar","char","toLowerCase","charAt","slice","mapBoxData","root","result","node","mapBoxDataChildren","boxKey","boxName","Array","isArray","id","name","children","item","childBoxKey","indexOf","itemName","getItemName","childNode","hasProperties","some","prop","childrenKeys","isCompoundArray","data","onlyChild","propsBoxKey","dataWithoutChildren","childKey","nameAttr","find","undefined","_defineProperty","obj","configurable","writable"],"mappings":"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","file":"static/js/27.48f246b7.chunk.js","sourcesContent":["import defineProperty from \"./defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","export const SIZE_UNIT = \"vw\";\nexport const SCENE_WIDTH = 1000;\nexport const BASE_HUE = 340;\nexport const HUE_INCREMENT = -130;\nexport const BOX_MARGIN = 0.2; // How much extra space there is around each box\n","export enum PerspectiveType{\n    SIDE_VIEW,\n    TOP_VIEW\n}\n","import {SIZE_UNIT} from \"./JurassicUnix.constants\";\nimport {Coordinates} from './types/coordinates';\nimport {PerspectiveType} from \"./types/perspective-type\";\nimport {Perspective} from \"./types/perspective\";\nimport {BoxData} from \"./types/box-data\";\n\nexport function getPerspectiveFor(x: number, y: number, z: number, width: number, perspectiveType: PerspectiveType): Perspective {\n    // x, y, z: coordinates of the lower left corner of the object closest to the observer (with maximum z)\n    // width: the width of the object we're looking at (size in direction x)\n    // output: offset to which we need to move the view in order to see the object\n\n    // First we determine where the centre of the object's top side is (For the sake of simplicity we assume the object's width equals its length)\n    const objectTopCentre: Coordinates = { x: -width*0.5 - x, y: -y, z: width*0.5 - z };\n    let offset: Coordinates;\n\n    if(perspectiveType===PerspectiveType.SIDE_VIEW){\n        offset= { x: 0, y: width*0.4, z: -width*0.8 };\n    } else{\n        const windowAspectRatio: number = window.innerWidth/window.innerHeight;\n        offset= { x: 0, y: width*Math.max(1, windowAspectRatio)*0.6, z: 0 };\n    }\n\n    return {viewPoint:addCoordinates(objectTopCentre, offset), perspectiveType};\n}\n\nexport function get3DTranslation(offset: Coordinates): string {\n    return (\n        \"translate3d(\" +\n        offset.x +\n        SIZE_UNIT +\n        \", \" +\n        offset.y +\n        SIZE_UNIT +\n        \", \" +\n        offset.z +\n        SIZE_UNIT +\n        \")\"\n    );\n}\n\nexport function get3DRotation(direction: 'x'|'y'|'z', degrees: number): string {\n    return (\n        \"rotate\"+direction.toUpperCase()+\"(\" +\n        degrees+\n        \"deg)\"\n    );\n}\n\nexport function addCoordinates(position1?: Coordinates, position2?: Coordinates): Coordinates {\n    const pos1 = position1 || { x: 0, y: 0, z: 0 };\n    const pos2 = position2 || { x: 0, y: 0, z: 0 };\n\n    return {\n        x: pos1.x + pos2.x,\n        y: pos1.y + pos2.y,\n        z: pos1.z + pos2.z,\n    };\n}\n\nexport function isPrimitive(value: any) {\n    return value !== Object(value);\n}\n\nfunction isPrimitiveProperty(prop: any) {\n    return !Array.isArray(prop) && isPrimitive(prop)\n}\n\nfunction isCompoundProperty(prop: any) {\n    return !Array.isArray(prop) && !isPrimitive(prop)\n}\n\nfunction isCompoundArray(prop: any) {\n    return Array.isArray(prop) && prop.length > 0 && !isPrimitive(prop[0])\n}\n\nexport function capitalize(str: string) {\n    const spaced: string = str.split('').reduce((newString, nextChar)=>newString+(isUpperCase(nextChar)?(' '+nextChar.toLowerCase()):nextChar), '');\n    return `${spaced.charAt(0).toUpperCase()}${spaced.slice(1)}`;\n}\n\nfunction isUpperCase(char: string){\n    return char === char.toUpperCase() && char !== char.toLowerCase();\n}\n\nexport function mapBoxData(root: any): BoxData[] {\n    let result: BoxData[] = [];\n    const keys = Object.keys(root)\n    keys.forEach((key) => {\n        const node: BoxData|null = mapBoxDataChildren(root[key], key + '-' + keys.indexOf(key), capitalize(key))\n        if (node) {\n            result.push(node);\n        }\n    });\n    return result;\n}\n\nfunction getItemName(item: any): string {\n    // TODO: figure out a nicer way to get the box name\n\n    // The box name is in one of these attributes, depending on what kind of data we have:\n    /*Award=>awarder\n        Education=>area or studyType\n        Interest=>name\n        Language=>language\n        Project=>name\n        Publication=>name\n        Reference=>name\n        Skill=>name\n        Volunteer=>organization\n        Work=>name\n        Profile=>network*/\n\n    const nameAttr: string|undefined = ['awarder', 'area', 'studyType', 'name', 'language', 'name', 'organization', 'network'].find(nameAttr=>item[nameAttr]!==undefined);\n\n    return nameAttr?item[nameAttr]:'';\n}\n\nfunction mapBoxDataChildren(root: any, boxKey: string, boxName: string): BoxData | null {\n    if (isPrimitive(root)) {\n        return null;\n    }\n\n    if (Array.isArray(root)) {\n        if (root.length === 0) {\n            return null;\n        }\n        if (root.length === 1) {\n            return mapBoxDataChildren(root[0], boxKey, boxName);\n        }\n\n        const node: BoxData = {\n            id: boxKey,\n            name: boxName,\n            children: [],\n        };\n        root.forEach(item => {\n            const childBoxKey = boxKey + '-' + root.indexOf(item);\n            const itemName = getItemName(item)\n            const childNode = mapBoxDataChildren(item, childBoxKey, itemName);\n            if (childNode) {\n                node.children.push(childNode);\n            }\n        });\n\n        return node;\n    }\n\n    const keys = Object.keys(root);\n    const hasProperties = keys.some(key => isPrimitiveProperty(root[key]));\n    const childrenKeys = keys.filter(key => (isCompoundProperty(root[key]) || isCompoundArray(root[key])));\n\n    if (hasProperties && childrenKeys.length === 0) {\n        return {\n            id: boxKey,\n            name: boxName,\n            data: root,\n            children: [],\n        };\n    }\n\n    if (!hasProperties && childrenKeys.length === 1) {\n        const childBoxKey = boxKey + '-' + childrenKeys[0];\n        const onlyChild = root[childrenKeys[0]];\n        return mapBoxDataChildren(onlyChild, childBoxKey + '-' + 0, getItemName(onlyChild));\n    }\n\n    const node: BoxData = {\n        id: boxKey,\n        name: boxName,\n        children: [],\n    };\n\n    if (hasProperties) {\n        const propsBoxKey = boxKey + '-' + 0;\n        const dataWithoutChildren={...root}\n        childrenKeys.forEach(key=>delete dataWithoutChildren[key]); // We are going to add childrenKeys as separate boxes, so we can remove them from here\n\n        node.children.push({\n            id: propsBoxKey,\n            name: \"Info\",\n            data: dataWithoutChildren,\n            children: [],\n        });\n    }\n\n    childrenKeys.forEach(childKey => {\n        const childBoxKey = boxKey + '-' + childKey + '-' + childrenKeys.indexOf(childKey);\n        const childNode = mapBoxDataChildren(root[childKey], childBoxKey, capitalize(childKey));\n        if (childNode) {\n            node.children.push(childNode);\n        }\n    });\n\n    return node;\n}\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}"],"sourceRoot":""}